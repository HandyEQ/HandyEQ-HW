#include "digilent_nexys4.h"
#include "gpio.h"
#include "irq.h"
#include "sevenseg.h"

extern int interruptServedRecently;
extern int dbncCtr;
extern int A;
extern int B;
extern int flagGPIOA;
extern int currGPIOBState;
extern int delayCtr;
extern int flag3;
extern int timerFlagSeg;

int OLEDChars[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x00, NUL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x01, SOH
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x02, STX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, ETX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, EOT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x05, ENQ
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x06, ACK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x07, BEL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x08, BS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x09, HT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0A, LF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0B, VT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0C, FF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0D, CR
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0E, SO
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0F, SI
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x10, DLE
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x11, DC1
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x12, DC2
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC3
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC4
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x15, NAK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x16, SYN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x17, ETB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x18, CAN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x19, EM
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1A, SUB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1B, ESC
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1C, FS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1D, GS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1E, RS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1F, US

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x20, space
  0x00,0x00,0x00,0x5f,0x00,0x00,0x00,0x00,    // 0x21, !
  0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,    // 0x22, "
  0x64,0x3c,0x26,0x64,0x3c,0x26,0x24,0x00,    // 0x23, #
  0x26,0x49,0x49,0x7f,0x49,0x49,0x32,0x00,    // 0x23, $
  0x42,0x25,0x12,0x08,0x24,0x52,0x21,0x00,    // 0x25, %
  0x20,0x50,0x4e,0x55,0x22,0x58,0x28,0x00,    // 0x26, &
  0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,    // 0x27, '
  0x00,0x00,0x1c,0x22,0x41,0x00,0x00,0x00,    // 0x28, (
  0x00,0x00,0x00,0x41,0x22,0x1c,0x00,0x00,    // 0x29, )
  0x00,0x15,0x15,0x0e,0x0e,0x15,0x15,0x00,    // 0x2A, *
  0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,    // 0x2B, +
  0x00,0x00,0x00,0x50,0x30,0x00,0x00,0x00,    // 0x2C, ,
  0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,    // 0x2D, -
  0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,    // 0x2E, .
  0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,    // 0x2F, /
  0x00,0x3e,0x41,0x41,0x41,0x3e,0x00,0x00,    // 0x30, 0
  0x00,0x00,0x41,0x7f,0x40,0x00,0x00,0x00,    // 0x31, 1
  0x00,0x42,0x61,0x51,0x49,0x6e,0x00,0x00,    // 0x32, 2
  0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00,    // 0x33, 3
  0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x00,    // 0x33, 4
  0x00,0x27,0x49,0x49,0x49,0x71,0x00,0x00,    // 0x35, 5
  0x00,0x3c,0x4a,0x49,0x48,0x70,0x00,0x00,    // 0x36, 6
  0x00,0x43,0x21,0x11,0x0d,0x03,0x00,0x00,    // 0x37, 7
  0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,    // 0x38, 8
  0x00,0x06,0x09,0x49,0x29,0x1e,0x00,0x00,    // 0x39, 9
  0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,    // 0x3A, :
  0x00,0x00,0x00,0x52,0x30,0x00,0x00,0x00,    // 0x3B, //
  0x00,0x00,0x08,0x14,0x14,0x22,0x00,0x00,    // 0x3C, <
  0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,    // 0x3D, =
  0x00,0x00,0x22,0x14,0x14,0x08,0x00,0x00,    // 0x3E, >
  0x00,0x02,0x01,0x59,0x05,0x02,0x00,0x00,    // 0x3F, ?
  0x3e,0x41,0x5d,0x55,0x4d,0x51,0x2e,0x00,    // 0x40, @
  0x40,0x7c,0x4a,0x09,0x4a,0x7c,0x40,0x00,    // 0x41, A
  0x41,0x7f,0x49,0x49,0x49,0x49,0x36,0x00,    // 0x42, B
  0x1c,0x22,0x41,0x41,0x41,0x41,0x22,0x00,    // 0x43, C
  0x41,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x44, D
  0x41,0x7f,0x49,0x49,0x5d,0x41,0x63,0x00,    // 0x45, E
  0x41,0x7f,0x49,0x09,0x1d,0x01,0x03,0x00,    // 0x46, F
  0x1c,0x22,0x41,0x49,0x49,0x3a,0x08,0x00,    // 0x47, G
  0x41,0x7f,0x08,0x08,0x08,0x7f,0x41,0x00,    // 0x48, H
  0x00,0x41,0x41,0x7F,0x41,0x41,0x00,0x00,    // 0x49, I
  0x30,0x40,0x41,0x41,0x3F,0x01,0x01,0x00,    // 0x4A, J
  0x41,0x7f,0x08,0x0c,0x12,0x61,0x41,0x00,    // 0x4B, K
  0x41,0x7f,0x41,0x40,0x40,0x40,0x60,0x00,    // 0x4C, L
  0x41,0x7f,0x42,0x0c,0x42,0x7f,0x41,0x00,    // 0x4D, M
  0x41,0x7f,0x42,0x0c,0x11,0x7f,0x01,0x00,    // 0x4E, N
  0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x4F, O
  0x41,0x7f,0x49,0x09,0x09,0x09,0x06,0x00,    // 0x50, P
  0x0c,0x12,0x21,0x21,0x61,0x52,0x4c,0x00,    // 0x51, Q
  0x41,0x7f,0x09,0x09,0x19,0x69,0x46,0x00,    // 0x52, R
  0x66,0x49,0x49,0x49,0x49,0x49,0x33,0x00,    // 0x53, S
  0x03,0x01,0x41,0x7f,0x41,0x01,0x03,0x00,    // 0x54, T
  0x01,0x3f,0x41,0x40,0x41,0x3f,0x01,0x00,    // 0x55, U
  0x01,0x0f,0x31,0x40,0x31,0x0f,0x01,0x00,    // 0x56, V
  0x01,0x1f,0x61,0x14,0x61,0x1f,0x01,0x00,    // 0x57, W
  0x41,0x41,0x36,0x08,0x36,0x41,0x41,0x00,    // 0x58, X
  0x01,0x03,0x44,0x78,0x44,0x03,0x01,0x00,    // 0x59, Y
  0x43,0x61,0x51,0x49,0x45,0x43,0x61,0x00,    // 0x5A, Z
  0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x00,    // 0x5B, [
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00,    // 0x5C,
  0x00,0x00,0x41,0x41,0x7f,0x00,0x00,0x00,    // 0x5D, ]
  0x00,0x04,0x02,0x01,0x01,0x02,0x04,0x00,    // 0x5E, ^
  0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,    // 0x5F, _printf("INIT OLED");
  0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,    // 0x60, `
  0x00,0x34,0x4a,0x4a,0x4a,0x3c,0x40,0x00,    // 0x61, a
  0x00,0x41,0x3f,0x48,0x48,0x48,0x30,0x00,    // 0x62. b
  0x00,0x3c,0x42,0x42,0x42,0x24,0x00,0x00,    // 0x63, c
  0x00,0x30,0x48,0x48,0x49,0x3f,0x40,0x00,    // 0x63, d
  0x00,0x3c,0x4a,0x4a,0x4a,0x2c,0x00,0x00,    // 0x65, e
  0x00,0x00,0x48,0x7e,0x49,0x09,0x00,0x00,    // 0x66, f
  0x00,0x26,0x49,0x49,0x49,0x3f,0x01,0x00,    // 0x67, g
  0x41,0x7f,0x48,0x04,0x44,0x78,0x40,0x00,    // 0x68, h
  0x00,0x00,0x44,0x7d,0x40,0x00,0x00,0x00,    // 0x69, i
  0x00,0x00,0x40,0x44,0x3d,0x00,0x00,0x00,    // 0x6A, j
  0x41,0x7f,0x10,0x18,0x24,0x42,0x42,0x00,    // 0x6B, k
  0x00,0x40,0x41,0x7f,0x40,0x40,0x00,0x00,    // 0x6C, l
  0x42,0x7e,0x02,0x7c,0x02,0x7e,0x40,0x00,    // 0x6D, m
  0x42,0x7e,0x44,0x02,0x42,0x7c,0x40,0x00,    // 0x6E, n
  0x00,0x3c,0x42,0x42,0x42,0x3c,0x00,0x00,    // 0x6F, o
  0x00,0x41,0x7f,0x49,0x09,0x09,0x06,0x00,    // 0x70, p
  0x00,0x06,0x09,0x09,0x49,0x7f,0x41,0x00,    // 0x71, q
  0x00,0x42,0x7e,0x44,0x02,0x02,0x04,0x00,    // 0x72, r
  0x00,0x64,0x4a,0x4a,0x4a,0x36,0x00,0x00,    // 0x73, s
  0x00,0x04,0x3f,0x44,0x44,0x20,0x00,0x00,    // 0x73, t
  0x00,0x02,0x3e,0x40,0x40,0x22,0x7e,0x40,    // 0x75, u
  0x02,0x0e,0x32,0x40,0x32,0x0e,0x02,0x00,    // 0x76, v
  0x02,0x1e,0x62,0x18,0x62,0x1e,0x02,0x00,    // 0x77, w
  0x42,0x62,0x14,0x08,0x14,0x62,0x42,0x00,    // 0x78, x
  0x01,0x43,0x45,0x38,0x05,0x03,0x01,0x00,    // 0x79, y
  0x00,0x46,0x62,0x52,0x4a,0x46,0x62,0x00,    // 0x7A, z
  0x00,0x00,0x08,0x36,0x41,0x00,0x00,0x00,    // 0x7B, {
  0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,    // 0x7C, |
  0x00,0x00,0x00,0x41,0x36,0x08,0x00,0x00,    // 0x7D, }
  0x00,0x18,0x08,0x08,0x10,0x10,0x18,0x00,    // 0x7E, ~
  0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55     // 0x7F, DEL
};

void NEXYS4_GPIO_Init()
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* GPIOA */

  GPIO_DeInit(GPIOA);

  GPIO_StructInit(&GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9
                              | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /* GPIOB */

  GPIO_DeInit(GPIOB);

  GPIO_StructInit(&GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10
                              | GPIO_Pin_11 | GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIOA -> interrupt = 0x0000FFFF; // enable interrupts for inputs
  GPIOA -> int_edg = 0x0000FFFF; // edge triggered
  GPIOA -> int_pol = 0x0000FFFF; // rising edge

  catch_interrupt(GPIOAB_IRQHandler, 9);
  enable_irq(9);

  GPIOB -> interrupt = 0x03E0FFFF; // enable interrupts for inputs
  GPIOB -> int_edg = 0x03E0FFFF; // edge triggered
  GPIOB -> int_pol = 0x03E0CFFF; // rising edge (falling edge for encoder channels)

  catch_interrupt(GPIOAB_IRQHandler, 10);
  enable_irq(10);
}

void NEXYS4_TIMER_Init()
{
  TIMERA -> scaler = 0x00000003; // divides 50 MHz by 4 (3 + 1)
  TIMERA -> scalerReload = 0x00000003; // divides 50 MHz by 4
  TIMERA -> config = 0x00000001;
  TIMERA -> timerLatchCfg = 0x00000000;

  TIMERA -> timer1counter = 1249; //0.1 ms overall
  TIMERA -> timer1reload = 1249;
  TIMERA -> timer1ctrl = 0x0000000B;

  TIMERA -> timer2counter = 12499; // divide 12.5 MHz by 12.5k (BEBC1F + 1) 0,001 s overall
  TIMERA -> timer2reload = 12499; // divide 12.5 MHz by 12.5k
  TIMERA -> timer2ctrl = 0x0000000B;

  catch_interrupt(TIMER1_IRQHandler, 7);
  enable_irq(7);

  catch_interrupt(TIMER1_IRQHandler, 8);
  enable_irq(8);
}

void NEXYS4_OLED_SPI_Init()
{
	//printf("INIT OLED\n");
  GPIO_SetBits(GPIOB, NEXYS4_OLED_VDDC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_VBATC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HIGH
  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1 (reset off)

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to LOW
	
	//printf("Resetted bits\n");
  SPIA -> mode = 0x3A002384; //CPOL = 1, CPHA = 1, DIV16 = 1, REV = 0 (LSB first), MS = 1 (master), FACT = 1, PM = 0, IGSEL = 1 ignore spi sel, 7-CLK gap inserted between following bytes (does not help)

  SPIA -> mode |= 0x00700000; //Word length = 8 (7+1)

  SPIA -> mode |= 0x01000000; //EN = 1
  	//printf("wrote to SPIA\n");
  //1. Apply power to VDD.
  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VDDC);

  delayCtr = 0;
  while (delayCtr < 50){
  	//printf("%d\n", delayCtr);
  }

  //2. Send Display Off command. 0xAE 1010 1110 - 0111 0101 75
  SPI_SendByte(0xAE);
  //SPI_SendByte(0x75);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_RES); //RES == 0

  delayCtr = 0;
  while (delayCtr < 50){
  	//printf("%d\n", delayCtr);
  }

  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1
  
  delayCtr = 0;
  while (delayCtr < 50){
  	//printf("%d\n", delayCtr);
  }

//printf("Send Bytes 1\n");
  SPI_SendByte(0x8D);
  SPI_SendByte(0x14);
  //SPI_SendByte(0xB1);
  //SPI_SendByte(0x28);

//printf("Send Bytes 2\n");
  SPI_SendByte(0xD9);
  SPI_SendByte(0xF1);
  //SPI_SendByte(0x9B);
  //SPI_SendByte(0x8F);

//printf("Reset Bits 1\n");
  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VBATC);
  
  delayCtr = 0;
  while (delayCtr < 1050){
  	//printf("%d\n", delayCtr);
  }

//printf("Send Bytes 3\n");
  SPI_SendByte(0x81);
  SPI_SendByte(0x0F);
  //SPI_SendByte(0x81);
  //SPI_SendByte(0xF0);

//printf("Send Bytes 4\n");
  SPI_SendByte(0xA1);
  SPI_SendByte(0xC8);
  //SPI_SendByte(0x85);
  //SPI_SendByte(0x13);

//printf("Send Bytes 5\n");
  SPI_SendByte(0xDA);
  SPI_SendByte(0x20);
  //SPI_SendByte(0x5B);
  //SPI_SendByte(0x04);

  SPI_SendByte(0xAF);
//printf("DONE\n");
}

void NEXYS4_SEVENSEG_Init()
{
	SEVENSEG_Init();
	SEVENSEG_WriteString("        ");
}


/*** IRQ Handlers ***/
void GPIOAB_IRQHandler(int irq)
{
  if (irq == 9) // switches
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    //lreg[IPEND/4] &= ~(1 << irq);
	//irq_struct->irqpend &= ~(1 << irq); // clear pending bit
	clear_irq(irq);
    //not necessary here, switches to be read by polling
    flagGPIOA = 1;
  } 
  else if (irq == 10) // btns, encoder
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    //lreg[IPEND/4] &= ~(1 << irq);
	//irq_struct->irqpend &= ~(1 << irq); // clear pending bit
	clear_irq(irq);
    if (interruptServedRecently == 0)
    {
      A = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
      B = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);

      /*if(A && !B) {// && prevB
        if (encDir < 7) encDir++;
      }
      else if(!A && B) {// && prevA
        if(encDir > 0) encDir--;
      }
      else
      {
        //encDir = 0;
        //encDirChar = '0';
      }*/

      currGPIOBState = GPIO_ReadInputData(GPIOB);

      dbncCtr = 0;
      interruptServedRecently = 1;
    }
  }
}

void TIMER1_IRQHandler(int irq) {
  	if (irq == 7){ 
	//having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    	//lreg[IPEND/4] &= ~(1 << irq);
	//irq_struct->irqpend &= ~(1 << irq); // clear pending bit
		clear_irq(irq);
    		TIMERA -> timer1ctrl |= 0x00000010;

    		dbncCtr++;
    		delayCtr++;
	} else if (irq == 8){
		//having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    		//lreg[IPEND/4] &= ~(1 << irq);
		//irq_struct->irqpend &= ~(1 << irq); // clear pending bit
		clear_irq(irq);
		TIMERA -> timer2ctrl |= 0x00000010;
    		flag3 = 1;
		timerFlagSeg = 1;
	}
}

/* SPI and OLED functions */
void SPI_SendByte(int i)
{
  int j = 0;

  j |= (i & 1) << 7;
  j |= (i & 2) << 5;
  j |= (i & 4) << 3;
  j |= (i & 8) << 1;
  j |= (i & 16) >> 1;
  j |= (i & 32) >> 3;
  j |= (i & 64) >> 5;
  j |= (i & 128) >> 7;

  while (!((SPIA -> event) & 0x100)); //wait till NotFull bit is 1
  
  SPIA -> transmit = j;

  for (j = 0; j < 20; j++); // waiting for the flag is not enough, extra delay needs to be inserted, 20 is the min OK value

  //delayCtr = 0; // timer waiter function since NotFull checking does not work as intended
  //while (delayCtr < 2);
}

void OLED_SendChar(char c)
{
  int i;

  //GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (i = 0; i < 8; i++)
  {
    SPI_SendByte(OLEDChars[c * 8 + i]); // fetch the correct value from the char array
  }
}

void OLED_SendString(int line, char* s)
{
  /* Significant improvement here: keep four global line-variable strings for the four lines, and when this
     function is called check if the string to be written is the same the one that is already displayed
     (stored in the global line-variable). If not, overwrite the line-variable and print to display, but if yes,
     do nothing. */
  int i = 0;

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  SPI_SendByte(0xB0 + line); // cmd to set line to write to
  SPI_SendByte(0x10); // set higher nibble of start segment (both are 0s = beginning of the line)
  SPI_SendByte(0x00); // set lower nibble of start segment (both are 0s = beginning of the line)

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data

  	i = 0;
  	while (s[i] && (i < 16))
  	{
    		OLED_SendChar(s[i]);
    		i++;
  	}
	/*while (i < 16) // clear line
  	{
    		OLED_SendChar(' '); // the segment ctr is incremented automatically, it will be at the beginning of the line after this while-case
    		i++;
	}*/
}


void OLED_SendStringPos(int line, char* s, int pos)
{
  /* Significant improvement here: keep four global line-variable strings for the four lines, and when this
     function is called check if the string to be written is the same the one that is already displayed
     (stored in the global line-variable). If not, overwrite the line-variable and print to display, but if yes,
     do nothing. */
  int i = 0;
  int col1 = 0, col2 = 0;

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command
  
  col1 = (int)(pos/2);
  col2 = (int)(pos%2)*8;

  SPI_SendByte(0xB0 + line); // cmd to set line to write to
  SPI_SendByte(0x10 + col1); // set higher nibble of start segment (both are 0s = beginning of the line)
  SPI_SendByte(0x00 + col2); // set lower nibble of start segment (both are 0s = beginning of the line)

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data

  	i = 0;
  	while (s[i] && (i < (16-pos)))
  	{
    		OLED_SendChar(s[i]);
    		i++;
  	}
	/*while (i < 16) // clear line
  	{
    		OLED_SendChar(' '); // the segment ctr is incremented automatically, it will be at the beginning of the line after this while-case
    		i++;
	}*/
}
