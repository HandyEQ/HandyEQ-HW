// This file contains the board specific functions concerning the OLED display, GPIO ports,
// timers and seven-segment displays.

#include "digilent_nexys4.h"
#include "gpio.h"
#include "irq.h"
#include "sevenseg.h"

/* shared variables */
extern int interruptServedRecently;
extern int dbncCtr;
extern int A;
extern int B;
extern int flagGPIOA;
extern int currGPIOBState;
extern int delayCtr;
extern int flag3;
extern int timerFlagSeg;

// character library, every cahracter is denoted by its ASCII value, one character consists of 8 bytes
int OLEDChars[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x00, NUL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x01, SOH
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x02, STX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, ETX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, EOT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x05, ENQ
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x06, ACK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x07, BEL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x08, BS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x09, HT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0A, LF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0B, VT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0C, FF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0D, CR
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0E, SO
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0F, SI
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x10, DLE
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x11, DC1
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x12, DC2
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC3
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC4
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x15, NAK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x16, SYN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x17, ETB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x18, CAN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x19, EM
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1A, SUB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1B, ESC
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1C, FS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1D, GS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1E, RS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1F, US

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x20, space
  0x00,0x00,0x00,0x5f,0x00,0x00,0x00,0x00,    // 0x21, !
  0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,    // 0x22, "
  0x64,0x3c,0x26,0x64,0x3c,0x26,0x24,0x00,    // 0x23, #
  0x26,0x49,0x49,0x7f,0x49,0x49,0x32,0x00,    // 0x23, $
  0x42,0x25,0x12,0x08,0x24,0x52,0x21,0x00,    // 0x25, %
  0x20,0x50,0x4e,0x55,0x22,0x58,0x28,0x00,    // 0x26, &
  0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,    // 0x27, '
  0x00,0x00,0x1c,0x22,0x41,0x00,0x00,0x00,    // 0x28, (
  0x00,0x00,0x00,0x41,0x22,0x1c,0x00,0x00,    // 0x29, )
  0x00,0x15,0x15,0x0e,0x0e,0x15,0x15,0x00,    // 0x2A, *
  0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,    // 0x2B, +
  0x00,0x00,0x00,0x50,0x30,0x00,0x00,0x00,    // 0x2C, ,
  0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,    // 0x2D, -
  0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,    // 0x2E, .
  0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,    // 0x2F, /
  0x00,0x3e,0x41,0x41,0x41,0x3e,0x00,0x00,    // 0x30, 0
  0x00,0x00,0x41,0x7f,0x40,0x00,0x00,0x00,    // 0x31, 1
  0x00,0x42,0x61,0x51,0x49,0x6e,0x00,0x00,    // 0x32, 2
  0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00,    // 0x33, 3
  0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x00,    // 0x33, 4
  0x00,0x27,0x49,0x49,0x49,0x71,0x00,0x00,    // 0x35, 5
  0x00,0x3c,0x4a,0x49,0x48,0x70,0x00,0x00,    // 0x36, 6
  0x00,0x43,0x21,0x11,0x0d,0x03,0x00,0x00,    // 0x37, 7
  0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,    // 0x38, 8
  0x00,0x06,0x09,0x49,0x29,0x1e,0x00,0x00,    // 0x39, 9
  0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,    // 0x3A, :
  0x00,0x00,0x00,0x52,0x30,0x00,0x00,0x00,    // 0x3B, //
  0x00,0x00,0x08,0x14,0x14,0x22,0x00,0x00,    // 0x3C, <
  0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,    // 0x3D, =
  0x00,0x00,0x22,0x14,0x14,0x08,0x00,0x00,    // 0x3E, >
  0x00,0x02,0x01,0x59,0x05,0x02,0x00,0x00,    // 0x3F, ?
  0x3e,0x41,0x5d,0x55,0x4d,0x51,0x2e,0x00,    // 0x40, @
  0x40,0x7c,0x4a,0x09,0x4a,0x7c,0x40,0x00,    // 0x41, A
  0x41,0x7f,0x49,0x49,0x49,0x49,0x36,0x00,    // 0x42, B
  0x1c,0x22,0x41,0x41,0x41,0x41,0x22,0x00,    // 0x43, C
  0x41,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x44, D
  0x41,0x7f,0x49,0x49,0x5d,0x41,0x63,0x00,    // 0x45, E
  0x41,0x7f,0x49,0x09,0x1d,0x01,0x03,0x00,    // 0x46, F
  0x1c,0x22,0x41,0x49,0x49,0x3a,0x08,0x00,    // 0x47, G
  0x41,0x7f,0x08,0x08,0x08,0x7f,0x41,0x00,    // 0x48, H
  0x00,0x41,0x41,0x7F,0x41,0x41,0x00,0x00,    // 0x49, I
  0x30,0x40,0x41,0x41,0x3F,0x01,0x01,0x00,    // 0x4A, J
  0x41,0x7f,0x08,0x0c,0x12,0x61,0x41,0x00,    // 0x4B, K
  0x41,0x7f,0x41,0x40,0x40,0x40,0x60,0x00,    // 0x4C, L
  0x41,0x7f,0x42,0x0c,0x42,0x7f,0x41,0x00,    // 0x4D, M
  0x41,0x7f,0x42,0x0c,0x11,0x7f,0x01,0x00,    // 0x4E, N
  0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x4F, O
  0x41,0x7f,0x49,0x09,0x09,0x09,0x06,0x00,    // 0x50, P
  0x0c,0x12,0x21,0x21,0x61,0x52,0x4c,0x00,    // 0x51, Q
  0x41,0x7f,0x09,0x09,0x19,0x69,0x46,0x00,    // 0x52, R
  0x66,0x49,0x49,0x49,0x49,0x49,0x33,0x00,    // 0x53, S
  0x03,0x01,0x41,0x7f,0x41,0x01,0x03,0x00,    // 0x54, T
  0x01,0x3f,0x41,0x40,0x41,0x3f,0x01,0x00,    // 0x55, U
  0x01,0x0f,0x31,0x40,0x31,0x0f,0x01,0x00,    // 0x56, V
  0x01,0x1f,0x61,0x14,0x61,0x1f,0x01,0x00,    // 0x57, W
  0x41,0x41,0x36,0x08,0x36,0x41,0x41,0x00,    // 0x58, X
  0x01,0x03,0x44,0x78,0x44,0x03,0x01,0x00,    // 0x59, Y
  0x43,0x61,0x51,0x49,0x45,0x43,0x61,0x00,    // 0x5A, Z
  0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x00,    // 0x5B, [
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00,    // 0x5C,
  0x00,0x00,0x41,0x41,0x7f,0x00,0x00,0x00,    // 0x5D, ]
  0x00,0x04,0x02,0x01,0x01,0x02,0x04,0x00,    // 0x5E, ^
  0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,    // 0x5F, _printf("INIT OLED");
  0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,    // 0x60, `
  0x00,0x34,0x4a,0x4a,0x4a,0x3c,0x40,0x00,    // 0x61, a
  0x00,0x41,0x3f,0x48,0x48,0x48,0x30,0x00,    // 0x62. b
  0x00,0x3c,0x42,0x42,0x42,0x24,0x00,0x00,    // 0x63, c
  0x00,0x30,0x48,0x48,0x49,0x3f,0x40,0x00,    // 0x63, d
  0x00,0x3c,0x4a,0x4a,0x4a,0x2c,0x00,0x00,    // 0x65, e
  0x00,0x00,0x48,0x7e,0x49,0x09,0x00,0x00,    // 0x66, f
  0x00,0x26,0x49,0x49,0x49,0x3f,0x01,0x00,    // 0x67, g
  0x41,0x7f,0x48,0x04,0x44,0x78,0x40,0x00,    // 0x68, h
  0x00,0x00,0x44,0x7d,0x40,0x00,0x00,0x00,    // 0x69, i
  0x00,0x00,0x40,0x44,0x3d,0x00,0x00,0x00,    // 0x6A, j
  0x41,0x7f,0x10,0x18,0x24,0x42,0x42,0x00,    // 0x6B, k
  0x00,0x40,0x41,0x7f,0x40,0x40,0x00,0x00,    // 0x6C, l
  0x42,0x7e,0x02,0x7c,0x02,0x7e,0x40,0x00,    // 0x6D, m
  0x42,0x7e,0x44,0x02,0x42,0x7c,0x40,0x00,    // 0x6E, n
  0x00,0x3c,0x42,0x42,0x42,0x3c,0x00,0x00,    // 0x6F, o
  0x00,0x41,0x7f,0x49,0x09,0x09,0x06,0x00,    // 0x70, p
  0x00,0x06,0x09,0x09,0x49,0x7f,0x41,0x00,    // 0x71, q
  0x00,0x42,0x7e,0x44,0x02,0x02,0x04,0x00,    // 0x72, r
  0x00,0x64,0x4a,0x4a,0x4a,0x36,0x00,0x00,    // 0x73, s
  0x00,0x04,0x3f,0x44,0x44,0x20,0x00,0x00,    // 0x73, t
  0x00,0x02,0x3e,0x40,0x40,0x22,0x7e,0x40,    // 0x75, u
  0x02,0x0e,0x32,0x40,0x32,0x0e,0x02,0x00,    // 0x76, v
  0x02,0x1e,0x62,0x18,0x62,0x1e,0x02,0x00,    // 0x77, w
  0x42,0x62,0x14,0x08,0x14,0x62,0x42,0x00,    // 0x78, x
  0x01,0x43,0x45,0x38,0x05,0x03,0x01,0x00,    // 0x79, y
  0x00,0x46,0x62,0x52,0x4a,0x46,0x62,0x00,    // 0x7A, z
  0x00,0x00,0x08,0x36,0x41,0x00,0x00,0x00,    // 0x7B, {
  0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,    // 0x7C, |
  0x00,0x00,0x00,0x41,0x36,0x08,0x00,0x00,    // 0x7D, }
  0x00,0x18,0x08,0x08,0x10,0x10,0x18,0x00,    // 0x7E, ~
  0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55     // 0x7F, DEL
};

/**
  * @brief   This function initializes the GPIO ports of the board.
  * @param  None
  * @retval None
  */
void NEXYS4_GPIO_Init()
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* GPIOA */

  GPIO_DeInit(GPIOA);

  GPIO_StructInit(&GPIO_InitStructure);
  // set the switches to input
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9
                              | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

  GPIO_Init(GPIOA, &GPIO_InitStructure);
  // set the LEDs to output
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /* GPIOB */

  GPIO_DeInit(GPIOB);

  GPIO_StructInit(&GPIO_InitStructure);
  // set the buttons and the encoder extension board's devices to input
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  // set the three-color LEDs, the OLED display's signals and the testmodules to output
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10
                              | GPIO_Pin_11 | GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIOA -> interrupt = 0x0000FFFF; // enable interrupts for GPIOA inputs
  GPIOA -> int_edg = 0x0000FFFF; // edge triggered
  GPIOA -> int_pol = 0x0000FFFF; // rising edge

  catch_interrupt(GPIOAB_IRQHandler, 9);
  enable_irq(9);

  GPIOB -> interrupt = 0x03E0FFFF; // enable interrupts for GPIOB inputs
  GPIOB -> int_edg = 0x03E0FFFF; // edge triggered
  GPIOB -> int_pol = 0x03E0CFFF; // rising edge (falling edge for encoder channels)

  catch_interrupt(GPIOAB_IRQHandler, 10);
  enable_irq(10);
}

/**
  * @brief   This function initializes the timer module of the CPU.
  * @param  None
  * @retval None
  */
void NEXYS4_TIMER_Init()
{
  TIMERA -> scaler = 0x00000003; // divides 50 MHz by 4 (3 + 1)
  TIMERA -> scalerReload = 0x00000003; // divides 50 MHz by 4
  TIMERA -> config = 0x00000001; // set config to base state
  TIMERA -> timerLatchCfg = 0x00000000; // no latching is used

  TIMERA -> timer1counter = 1249; // divide 12.5 MHz by 1250 0.1 ms overall
  TIMERA -> timer1reload = 1249; // divide 12.5 MHz by 1250 0.1 ms overall
  TIMERA -> timer1ctrl = 0x0000000B; // interrupt enable, reload value from register on underflow, enable the counter

  TIMERA -> timer2counter = 12499; // divide 12.5 MHz by 12.5k 0.001 s overall
  TIMERA -> timer2reload = 12499; // divide 12.5 MHz by 12.5k 0.001 s overall
  TIMERA -> timer2ctrl = 0x0000000B; // interrupt enable, reload value from register on underflow, enable the counter

  catch_interrupt(TIMER1_IRQHandler, 7);
  enable_irq(7);

  catch_interrupt(TIMER1_IRQHandler, 8);
  enable_irq(8);
}

/**
  * @brief   This function initializes the SPI module and the OLED display.
  * @param  None
  * @retval None
  */
void NEXYS4_OLED_SPI_Init()
{
  GPIO_SetBits(GPIOB, NEXYS4_OLED_VDDC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_VBATC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HIGH
  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1 (reset off)

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to LOW
	
  SPIA -> mode = 0x3A002384; //CPOL = 1, CPHA = 1, DIV16 = 1, REV = 0 (LSB first), MS = 1 (master), FACT = 1, PM = 0, IGSEL = 1 ignore spi sel, 7-CLK gap inserted between following bytes (does not help)

  SPIA -> mode |= 0x00700000; //Word length = 8 (7+1)

  SPIA -> mode |= 0x01000000; //EN = 1
  //1. Apply power to VDD, logic power.
  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VDDC);

  delayCtr = 0; // wait 5 ms
  while (delayCtr < 50){
  }

  //2. Send Display Off command. 0xAE
  SPI_SendByte(0xAE);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_RES); //RES == 0

  delayCtr = 0; // wait 5 ms
  while (delayCtr < 50){
  }

  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1
  
  delayCtr = 0; // wait 5 ms
  while (delayCtr < 50){
  }

  // set screen specifics, such as contrast, polarity, etc.
  SPI_SendByte(0x8D);
  SPI_SendByte(0x14);

  SPI_SendByte(0xD9);
  SPI_SendByte(0xF1);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VBATC); // enable screen power
  
  delayCtr = 0; // wait 5 ms
  while (delayCtr < 1050){
  }

  SPI_SendByte(0x81);
  SPI_SendByte(0x0F);

  SPI_SendByte(0xA1);
  SPI_SendByte(0xC8);

  SPI_SendByte(0xDA);
  SPI_SendByte(0x20);

  //turn display on
  SPI_SendByte(0xAF);
}

/**
  * @brief   This function initializes the seven-segment displays on the board.
  * @param  None
  * @retval None
  */
void NEXYS4_SEVENSEG_Init()
{
	SEVENSEG_Init();
	SEVENSEG_WriteString("        ");
}


/*** IRQ Handlers ***/

/**
  * @brief   This function handles the interrupts from the GPIOs and the timers.
  * @param  IRQ designator
  * @retval None
  */
void GPIOAB_IRQHandler(int irq)
{
  if (irq == 9) // switches
  {
	  clear_irq(irq);
    // not necessary in the current application as switches are read by polling
    flagGPIOA = 1;
  } 
  else if (irq == 10) // btns, encoder
  {
	  clear_irq(irq);
    
    // debouncing
    if (interruptServedRecently == 0)
    {
      A = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
      B = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);

      currGPIOBState = GPIO_ReadInputData(GPIOB);

      dbncCtr = 0;
      interruptServedRecently = 1;
    }
  }
}

void TIMER1_IRQHandler(int irq) {
  	if (irq == 7){ 
		    clear_irq(irq);
    		TIMERA -> timer1ctrl |= 0x00000010; // clear timer pending bit by writing one to it

    		dbncCtr++;
    		delayCtr++;
	} else if (irq == 8){
		    clear_irq(irq);
		    TIMERA -> timer2ctrl |= 0x00000010; // clear timer pending bit by writing one to it
    		flag3 = 1;
		    timerFlagSeg = 1;
	}
}

/* SPI and OLED functions */

/**
  * @brief   This function initializes sends a byte thru SPI.
  * @param  byte to send
  * @retval None
  */
void SPI_SendByte(int i)
{
  int j = 0;

  // the MSB first sending is done by flipping the order of bits in the byte
  j |= (i & 1) << 7;
  j |= (i & 2) << 5;
  j |= (i & 4) << 3;
  j |= (i & 8) << 1;
  j |= (i & 16) >> 1;
  j |= (i & 32) >> 3;
  j |= (i & 64) >> 5;
  j |= (i & 128) >> 7;

  while (!((SPIA -> event) & 0x100)); //wait till NotFull bit is 1
  
  SPIA -> transmit = j; // transmit the byte

  for (j = 0; j < 20; j++); // waiting for the flag is not enough, extra delay needs to be inserted, 20 is the min OK value
}

/**
  * @brief   This function sends a character to the OLED display.
  * @param  character to send
  * @retval None
  */
void OLED_SendChar(char c)
{
  int i;
  
  for (i = 0; i < 8; i++)
  {
    SPI_SendByte(OLEDChars[c * 8 + i]); // fetch the correct value from the char library array
  }
}

/**
  * @brief   This function sends a string to the beginning of the OLED display's specified line.
  * @param  line to write to
  * @param  string to write
  * @retval None
  */
void OLED_SendString(int line, char* s)
{
  /* Significant improvement here: keep four global line-variable strings for the four lines, and when this
     function is called check if the string to be written is the same the one that is already displayed
     (stored in the global line-variable). If not, overwrite the line-variable and print to display, but if yes,
     do nothing. */
  int i = 0;

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); // let the display know that a command will be sent 

  SPI_SendByte(0xB0 + line); // set line to write to
  SPI_SendByte(0x10); // set higher nibble of start segment (both are 0s = beginning of the line)
  SPI_SendByte(0x00); // set lower nibble of start segment (both are 0s = beginning of the line)

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data

  	i = 0;
  	while (s[i] && (i < 16)) // send characters until a terminating 0 character or the end of the line (position 15) is written
  	{
    		OLED_SendChar(s[i]);
    		i++;
  	}
}

/**
  * @brief   This function sends a string to the OLED display's specified line and starts from the specified position.
  * @param  line to write to
  * @param  string to write
  * @param  position to start writing from
  * @retval None
  */
void OLED_SendStringPos(int line, char* s, int pos)
{
  /* Significant improvement here: keep four global line-variable strings for the four lines, and when this
     function is called check if the string to be written is the same the one that is already displayed
     (stored in the global line-variable). If not, overwrite the line-variable and print to display, but if yes,
     do nothing. */
  int i = 0;
  int col1 = 0, col2 = 0;

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command
  
  col1 = (int)(pos/2); // calculate the starting position of the character (can be every 8th of the 128 segments)
  col2 = (int)(pos%2)*8;

  SPI_SendByte(0xB0 + line); // cmd to set line to write to
  SPI_SendByte(0x10 + col1); // set higher nibble of start segment (both are 0s = beginning of the line)
  SPI_SendByte(0x00 + col2); // set lower nibble of start segment (both are 0s = beginning of the line)

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data

  	i = 0;
  	while (s[i] && (i < (16-pos))) // send characters until a terminating 0 character or the end of the line (position 15) is written
  	{
    		OLED_SendChar(s[i]);
    		i++;
  	}
}
