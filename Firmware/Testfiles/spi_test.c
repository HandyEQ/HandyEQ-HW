#include "uart.h"
#include "gpio.h"
#include "sevenseg.h"
#include "digilent_nexys4.h"

int flag = 0, flag2 = 0, flag3 = 0, delay = 0, gpioAPrev = 0, gpioBPrev = 0, gpioAChg = 0;
int prevA = 1, prevB = 0, encDir = 0;
int interruptServedRecently = 0, dbncCtr = 0;
int btnPress = 0;
int swRiseEdg = 0;
int A = 0, B = 0;
int currGPIOAState = 0;
int currGPIOBState = 0;
int pastGPIOAState = 0;
int pastGPIOBState = 0;
int delayCtr = 0;

char s[8] = "ABCDEF.-";
char encDirChar = '0';

int OLEDChars[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x00, NUL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x01, SOH
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x02, STX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, ETX
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x03, EOT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x05, ENQ
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x06, ACK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x07, BEL
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x08, BS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x09, HT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0A, LF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0B, VT
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0C, FF
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0D, CR
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0E, SO
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x0F, SI
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x10, DLE
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x11, DC1
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x12, DC2
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC3
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x13, DC4
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x15, NAK
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x16, SYN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x17, ETB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x18, CAN
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x19, EM
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1A, SUB
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1B, ESC
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1C, FS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1D, GS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1E, RS
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x1F, US

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    // 0x20, space
  0x00,0x00,0x00,0x5f,0x00,0x00,0x00,0x00,    // 0x21, !
  0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,    // 0x22, "
  0x64,0x3c,0x26,0x64,0x3c,0x26,0x24,0x00,    // 0x23, #
  0x26,0x49,0x49,0x7f,0x49,0x49,0x32,0x00,    // 0x23, $
  0x42,0x25,0x12,0x08,0x24,0x52,0x21,0x00,    // 0x25, %
  0x20,0x50,0x4e,0x55,0x22,0x58,0x28,0x00,    // 0x26, &
  0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,    // 0x27, '
  0x00,0x00,0x1c,0x22,0x41,0x00,0x00,0x00,    // 0x28, (
  0x00,0x00,0x00,0x41,0x22,0x1c,0x00,0x00,    // 0x29, )
  0x00,0x15,0x15,0x0e,0x0e,0x15,0x15,0x00,    // 0x2A, *
  0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,    // 0x2B, +
  0x00,0x00,0x00,0x50,0x30,0x00,0x00,0x00,    // 0x2C, ,
  0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,    // 0x2D, -
  0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,    // 0x2E, .
  0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,    // 0x2F, /
  0x00,0x3e,0x41,0x41,0x41,0x3e,0x00,0x00,    // 0x30, 0
  0x00,0x00,0x41,0x7f,0x40,0x00,0x00,0x00,    // 0x31, 1
  0x00,0x42,0x61,0x51,0x49,0x6e,0x00,0x00,    // 0x32, 2
  0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00,    // 0x33, 3
  0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x00,    // 0x33, 4
  0x00,0x27,0x49,0x49,0x49,0x71,0x00,0x00,    // 0x35, 5
  0x00,0x3c,0x4a,0x49,0x48,0x70,0x00,0x00,    // 0x36, 6
  0x00,0x43,0x21,0x11,0x0d,0x03,0x00,0x00,    // 0x37, 7
  0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,    // 0x38, 8
  0x00,0x06,0x09,0x49,0x29,0x1e,0x00,0x00,    // 0x39, 9
  0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,    // 0x3A, :
  0x00,0x00,0x00,0x52,0x30,0x00,0x00,0x00,    // 0x3B, //
  0x00,0x00,0x08,0x14,0x14,0x22,0x00,0x00,    // 0x3C, <
  0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,    // 0x3D, =
  0x00,0x00,0x22,0x14,0x14,0x08,0x00,0x00,    // 0x3E, >
  0x00,0x02,0x01,0x59,0x05,0x02,0x00,0x00,    // 0x3F, ?
  0x3e,0x41,0x5d,0x55,0x4d,0x51,0x2e,0x00,    // 0x40, @
  0x40,0x7c,0x4a,0x09,0x4a,0x7c,0x40,0x00,    // 0x41, A
  0x41,0x7f,0x49,0x49,0x49,0x49,0x36,0x00,    // 0x42, B
  0x1c,0x22,0x41,0x41,0x41,0x41,0x22,0x00,    // 0x43, C
  0x41,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x44, D
  0x41,0x7f,0x49,0x49,0x5d,0x41,0x63,0x00,    // 0x45, E
  0x41,0x7f,0x49,0x09,0x1d,0x01,0x03,0x00,    // 0x46, F
  0x1c,0x22,0x41,0x49,0x49,0x3a,0x08,0x00,    // 0x47, G
  0x41,0x7f,0x08,0x08,0x08,0x7f,0x41,0x00,    // 0x48, H
  0x00,0x41,0x41,0x7F,0x41,0x41,0x00,0x00,    // 0x49, I
  0x30,0x40,0x41,0x41,0x3F,0x01,0x01,0x00,    // 0x4A, J
  0x41,0x7f,0x08,0x0c,0x12,0x61,0x41,0x00,    // 0x4B, K
  0x41,0x7f,0x41,0x40,0x40,0x40,0x60,0x00,    // 0x4C, L
  0x41,0x7f,0x42,0x0c,0x42,0x7f,0x41,0x00,    // 0x4D, M
  0x41,0x7f,0x42,0x0c,0x11,0x7f,0x01,0x00,    // 0x4E, N
  0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x00,    // 0x4F, O
  0x41,0x7f,0x49,0x09,0x09,0x09,0x06,0x00,    // 0x50, P
  0x0c,0x12,0x21,0x21,0x61,0x52,0x4c,0x00,    // 0x51, Q
  0x41,0x7f,0x09,0x09,0x19,0x69,0x46,0x00,    // 0x52, R
  0x66,0x49,0x49,0x49,0x49,0x49,0x33,0x00,    // 0x53, S
  0x03,0x01,0x41,0x7f,0x41,0x01,0x03,0x00,    // 0x54, T
  0x01,0x3f,0x41,0x40,0x41,0x3f,0x01,0x00,    // 0x55, U
  0x01,0x0f,0x31,0x40,0x31,0x0f,0x01,0x00,    // 0x56, V
  0x01,0x1f,0x61,0x14,0x61,0x1f,0x01,0x00,    // 0x57, W
  0x41,0x41,0x36,0x08,0x36,0x41,0x41,0x00,    // 0x58, X
  0x01,0x03,0x44,0x78,0x44,0x03,0x01,0x00,    // 0x59, Y
  0x43,0x61,0x51,0x49,0x45,0x43,0x61,0x00,    // 0x5A, Z
  0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x00,    // 0x5B, [
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00,    // 0x5C,
  0x00,0x00,0x41,0x41,0x7f,0x00,0x00,0x00,    // 0x5D, ]
  0x00,0x04,0x02,0x01,0x01,0x02,0x04,0x00,    // 0x5E, ^
  0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,    // 0x5F, _
  0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,    // 0x60, `
  0x00,0x34,0x4a,0x4a,0x4a,0x3c,0x40,0x00,    // 0x61, a
  0x00,0x41,0x3f,0x48,0x48,0x48,0x30,0x00,    // 0x62. b
  0x00,0x3c,0x42,0x42,0x42,0x24,0x00,0x00,    // 0x63, c
  0x00,0x30,0x48,0x48,0x49,0x3f,0x40,0x00,    // 0x63, d
  0x00,0x3c,0x4a,0x4a,0x4a,0x2c,0x00,0x00,    // 0x65, e
  0x00,0x00,0x48,0x7e,0x49,0x09,0x00,0x00,    // 0x66, f
  0x00,0x26,0x49,0x49,0x49,0x3f,0x01,0x00,    // 0x67, g
  0x41,0x7f,0x48,0x04,0x44,0x78,0x40,0x00,    // 0x68, h
  0x00,0x00,0x44,0x7d,0x40,0x00,0x00,0x00,    // 0x69, i
  0x00,0x00,0x40,0x44,0x3d,0x00,0x00,0x00,    // 0x6A, j
  0x41,0x7f,0x10,0x18,0x24,0x42,0x42,0x00,    // 0x6B, k
  0x00,0x40,0x41,0x7f,0x40,0x40,0x00,0x00,    // 0x6C, l
  0x42,0x7e,0x02,0x7c,0x02,0x7e,0x40,0x00,    // 0x6D, m
  0x42,0x7e,0x44,0x02,0x42,0x7c,0x40,0x00,    // 0x6E, n
  0x00,0x3c,0x42,0x42,0x42,0x3c,0x00,0x00,    // 0x6F, o
  0x00,0x41,0x7f,0x49,0x09,0x09,0x06,0x00,    // 0x70, p
  0x00,0x06,0x09,0x09,0x49,0x7f,0x41,0x00,    // 0x71, q
  0x00,0x42,0x7e,0x44,0x02,0x02,0x04,0x00,    // 0x72, r
  0x00,0x64,0x4a,0x4a,0x4a,0x36,0x00,0x00,    // 0x73, s
  0x00,0x04,0x3f,0x44,0x44,0x20,0x00,0x00,    // 0x73, t
  0x00,0x02,0x3e,0x40,0x40,0x22,0x7e,0x40,    // 0x75, u
  0x02,0x0e,0x32,0x40,0x32,0x0e,0x02,0x00,    // 0x76, v
  0x02,0x1e,0x62,0x18,0x62,0x1e,0x02,0x00,    // 0x77, w
  0x42,0x62,0x14,0x08,0x14,0x62,0x42,0x00,    // 0x78, x
  0x01,0x43,0x45,0x38,0x05,0x03,0x01,0x00,    // 0x79, y
  0x00,0x46,0x62,0x52,0x4a,0x46,0x62,0x00,    // 0x7A, z
  0x00,0x00,0x08,0x36,0x41,0x00,0x00,0x00,    // 0x7B, {
  0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,    // 0x7C, |
  0x00,0x00,0x00,0x41,0x36,0x08,0x00,0x00,    // 0x7D, }
  0x00,0x18,0x08,0x08,0x10,0x10,0x18,0x00,    // 0x7E, ~
  0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55     // 0x7F, DEL
};

extern void *catch_interrupt(void func(), int irq);
int *lreg = (int *) 0x80000000;

#define ILEVEL 0x200
#define IPEND  0x204
#define IFORCE 0x208
#define ICLEAR 0x20c
#define IMASK  0x240

typedef struct
{
  int capability; //0x00
  int reserved[7]; //0x04 08 0C 10 14 18 1C
  int mode; //20
  int event; //24
  int mask; //28
  int command; //2C
  int transmit; //30
  int receive; //34
  // more to come
}SPI_TypeDef;

#define SPIA               ((SPI_TypeDef *) 0x80000C00)
void SPI_SendByte(int i);

void OLED_SendChar(char c);
void OLED_SendString(int line, char* s);

typedef struct
{
  int scaler; //0x00
  int scalerReload; //0x04
  int config; //08
  int timerLatchCfg; //0C
  int timer1counter; //10
  int timer1reload; //14
  int timer1ctrl; //18
  int timer1latch; //1C
  int timer2counter; //20
  int timer2reload; //24
  int timer2ctrl; //28
  int timer2latch; //2C
}TIMER_TypeDef;

#define TIMERA               ((TIMER_TypeDef *) 0x80000300)

enable_irq (int irq) 
{

  //lreg[ILEVEL/4] |= (1 << irq);
  lreg[ICLEAR/4] = (1 << irq);	// clear any pending irq
  lreg[IMASK/4] |= (1 << irq);	// unmaks irq
}

force_irq (int irq) { lreg[IFORCE/4] = (1 << irq); }


void irqhandler(int irq)
{
  if (irq == 7)
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    lreg[IPEND/4] &= ~(1 << irq);
    TIMERA -> timer1ctrl |= 0x00000010;

    dbncCtr++;
    delayCtr++;
  }
  else if (irq == 8)
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    lreg[IPEND/4] &= ~(1 << irq);
    TIMERA -> timer2ctrl |= 0x00000010;

    flag3 = 1;
  }
  else if (irq == 9) // switches
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    lreg[IPEND/4] &= ~(1 << irq);

    //not necessary here, switches to be read by polling
    pastGPIOAState = currGPIOAState;
    currGPIOAState = GPIO_ReadInputData(GPIOA);
  } 
  else if (irq == 10) // btns, encoder
  { //having simple 'if'-s instead of 'else if'-s for the other irq checks makes the output noisier
    lreg[IPEND/4] &= ~(1 << irq);

    if (interruptServedRecently == 0)
    {
      A = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
      B = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);

      /*if(A && !B) {// && prevB
        if (encDir < 7) encDir++;
      }
      else if(!A && B) {// && prevA
        if(encDir > 0) encDir--;
      }
      else
      {
        //encDir = 0;
        //encDirChar = '0';
      }*/

      currGPIOBState = GPIO_ReadInputData(GPIOB);

      dbncCtr = 0;
      interruptServedRecently = 1;
    }
  }
}

int main(void)
{
  int i = 10, j = 0;
  int sample = 0;
  int pwm;

  GPIO_InitTypeDef GPIO_InitStructure;

  putStr("Test Started\n\r");

  /* GPIOA */

  GPIO_DeInit(GPIOA);

  GPIO_StructInit(&GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9
                              | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

  GPIO_Init(GPIOA, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /* GPIOB */

  GPIO_DeInit(GPIOB);

  GPIO_StructInit(&GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 
                              | GPIO_Pin_21 | GPIO_Pin_22 | GPIO_Pin_23 | GPIO_Pin_24 | GPIO_Pin_25;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4
                              | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10
                              | GPIO_Pin_11 | GPIO_Pin_16 | GPIO_Pin_17 | GPIO_Pin_18 | GPIO_Pin_19 | GPIO_Pin_20
                              | GPIO_Pin_26 | GPIO_Pin_27 | GPIO_Pin_28 | GPIO_Pin_29 | GPIO_Pin_30 | GPIO_Pin_31;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

  GPIO_Init(GPIOB, &GPIO_InitStructure);

  GPIOA -> interrupt = 0x0000FFFF; // enable int's for inputs
  GPIOA -> int_edg = 0x0000FFFF; // edge triggered
  GPIOA -> int_pol = 0x0000FFFF; // rising edge

  catch_interrupt(irqhandler, 9);
  enable_irq(9);

  GPIOB -> interrupt = 0x03E0FFFF; // enable int's for inputs
  GPIOB -> int_edg = 0x03E0FFFF; // edge triggered
  GPIOB -> int_pol = 0x03E0CFFF; // rising edge (falling edge for encoder channels)

  catch_interrupt(irqhandler, 10);
  enable_irq(10);

  /* TIMER */

  TIMERA -> scaler = 0x00000003; // divides 50 MHz by 4 (3 + 1)
  TIMERA -> scalerReload = 0x00000003; // divides 50 MHz by 4
  TIMERA -> config = 0x00000001;
  TIMERA -> timerLatchCfg = 0x00000000;

  TIMERA -> timer1counter = 1249; //0.1 ms 3: 0.32 us  -------//12499; // 1 ms overall
  TIMERA -> timer1reload = 1249;
  TIMERA -> timer1ctrl = 0x0000000B;

  TIMERA -> timer2counter = 12499999; // divide 12.5 MHz by 12.5M (BEBC1F + 1) 1 s overall
  TIMERA -> timer2reload = 12499999; // divide 12.5 MHz by 12.5M
  TIMERA -> timer2ctrl = 0x0000000B;

  catch_interrupt(irqhandler, 7);
  enable_irq(7);

  catch_interrupt(irqhandler, 8);
  enable_irq(8);

  /* SEVENSEG */

  SEVENSEG_Init();

  /****************** OLED *****************************/


  GPIO_SetBits(GPIOB, NEXYS4_OLED_VDDC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_VBATC);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HIGH
  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1 (reset off)

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to LOW

  SPIA -> mode = 0x3A002204; //CPOL = 1, CPHA = 1, DIV16 = 1, REV = 0 (LSB first), MS = 1 (master), FACT = 1, PM = 0, IGSEL = 1 ignore spi sel

  SPIA -> mode |= 0x00700000; //Word length = 8 (7+1)

  SPIA -> mode |= 0x01000000; //EN = 1
  
  //1. Apply power to VDD.
  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VDDC);

  delayCtr = 0;
  while (delayCtr < 50);

  //2. Send Display Off command. 0xAE 1010 1110 - 0111 0101 75
  SPI_SendByte(0xAE);
  //SPI_SendByte(0x75);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_RES); //RES == 0

  delayCtr = 0;
  while (delayCtr < 50);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_RES); //RES == 1
  
  delayCtr = 0;
  while (delayCtr < 50);

  SPI_SendByte(0x8D);
  SPI_SendByte(0x14);
  //SPI_SendByte(0xB1);
  //SPI_SendByte(0x28);

  SPI_SendByte(0xD9);
  SPI_SendByte(0xF1);
  //SPI_SendByte(0x9B);
  //SPI_SendByte(0x8F);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VBATC);
  
  delayCtr = 0;
  while (delayCtr < 1050);

  SPI_SendByte(0x81);
  SPI_SendByte(0x0F);
  //SPI_SendByte(0x81);
  //SPI_SendByte(0xF0);

  SPI_SendByte(0xA1);
  SPI_SendByte(0xC8);
  //SPI_SendByte(0x85);
  //SPI_SendByte(0x13);

  SPI_SendByte(0xDA);
  SPI_SendByte(0x20);
  //SPI_SendByte(0x5B);
  //SPI_SendByte(0x04);

  SPI_SendByte(0xAF);
  //SPI_SendByte(0xF5);
  
  //SPI_SendByte(0xA5);
  //SPI_SendByte(0xA5);



  /*GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (flag = 0, flag2 = 0; flag < 8; flag++)
  {
    SPI_SendByte(OLEDChars['G' * 8 + flag]);
  }
  
  for (; flag < 16; flag++)
  {
    SPI_SendByte(OLEDChars['u' * 8 + flag - 8]);
  }
  
  for (; flag < 24; flag++)
  {
    SPI_SendByte(OLEDChars['y' * 8 + flag - 16]);
  }
  
  for (; flag < 32; flag++)
  {
    SPI_SendByte(OLEDChars['z' * 8 + flag - 24]);
  }*/

  OLED_SendString(0, "    HandyEQ\0");
  OLED_SendString(1, "$$$$$$$$$$$$$$$\0");
  OLED_SendString(2, "\0trash");
  OLED_SendString(3, "       Guyzzz...\0");
  
  /*for (flag = 0x20; flag < 128; flag++)
  {
    SPI_SendByte(OLEDChars[flag]);
  }

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  SPI_SendByte(0xB1); //line (page) 1
  //SPI_SendByte(0x8D);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (; flag < 256; flag++)
  {
    SPI_SendByte(OLEDChars[flag]);
  }

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  SPI_SendByte(0xB2); //line (page) 2
  //SPI_SendByte(0x4D);

  
  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (; flag < 384; flag++)
  {
    SPI_SendByte(OLEDChars[flag]);
  }

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  SPI_SendByte(0xB3); //line (page) 3
  //SPI_SendByte(0xCD);

  
  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (; flag < 512; flag++)
  {
    SPI_SendByte(OLEDChars[flag]);
  }*/

  /*GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HIGH

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_VBATC);

  delayCtr = 0;
  while (delayCtr < 100);

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to LO
  delayCtr = 0;
  while (delayCtr < 1);
  SPI_SendByte(0xAF);
  GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HI

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to LO
  delayCtr = 0;
  while (delayCtr < 1);

  SPI_SendByte(0xFF);
  SPI_SendByte(0xFF);
  SPI_SendByte(0xFF);

  GPIO_SetBits(GPIOB, NEXYS4_OLED_CS); //Slave Select to HIGH*/
  
  //3. Initialize display to desired operating mode.

  //4. Clear screen.

  //5. Apply power to VBAT.
  //GPIO_SetBits(GPIOA, GPIO_Pin_10);
  //6. Delay 100ms.
  //for (delay = 0; delay < 830; delay++);
  //7. Send Display On command. 0xAF 1010 1111 - 1111 0101 F5
  //SPIA -> transmit = 0xF5;

  //for (delay = 0; delay < 830; delay++);
  //GPIO_SetBits(GPIOA, GPIO_Pin_9); //RES == 1

  while (1)
  {
    s[0] = '.';
    s[1] = '.';
    s[2] = '.';
    s[3] = '.';
    s[4] = '.';
    s[5] = '.';
    s[6] = '.';
    s[7] = '.';

    s[encDir] = '0';

    SEVENSEG_WriteString(s);

    // Switches to LEDs
    GPIO_Write(GPIOA, GPIO_ReadInputData(GPIOA) << 16);

    if (flag3 && GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW15))
    {
      flag3 = 0;
      flag2 = 1;

      if (currGPIOAState != GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW0) ||
        currGPIOBState != GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW1) ||
        pastGPIOAState != GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW2) ||
        pastGPIOBState != GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW3))
      {
        A = 1;
      }


      currGPIOAState = GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW0);
      currGPIOBState = GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW1);
      pastGPIOAState = GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW2);
      pastGPIOBState = GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW3);
    }
    else if (!GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW15) && flag2)
    {
      flag2 = 0;

      OLED_SendString(0, "    HandyEQ\0");
      OLED_SendString(1, "$$$$$$$$$$$$$$$\0");
      OLED_SendString(2, "\0trash");
      OLED_SendString(3, "       Guyzzz...\0");
    }

    if (A)
    {
      A = 0;

      if (GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW0))
        OLED_SendString(0, "Switch 0 ON");
      else
        OLED_SendString(0, "Switch 0 OFF");

      if (GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW1))
        OLED_SendString(1, "Switch 1 ON");
      else
        OLED_SendString(1, "Switch 1 OFF");

      if (GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW2))
        OLED_SendString(2, "Switch 2 ON");
      else
        OLED_SendString(2, "Switch 2 OFF");

      if (GPIO_ReadInputDataBit(GPIOA, NEXYS4_SW3))
        OLED_SendString(3, "Switch 3 ON");
      else
        OLED_SendString(3, "Switch 3 OFF");
    }
  }
  return 0;
}

void SPI_SendByte(int i)
{
  int j = 0;

  j |= (i & 1) << 7;
  j |= (i & 2) << 5;
  j |= (i & 4) << 3;
  j |= (i & 8) << 1;
  j |= (i & 16) >> 1;
  j |= (i & 32) >> 3;
  j |= (i & 64) >> 5;
  j |= (i & 128) >> 7;

  //while ((SPIA -> event) & 0x100 != 0); //wait till NotFull bit is 1
  
  SPIA -> transmit = j;

  delayCtr = 0; // timer waiter function since NotFull checking does not work as intended
  while (delayCtr < 2);
  
  //while ((SPIA -> event) & 0x100 != 0); //wait till NotFull bit is 1
}

void OLED_SendChar(char c)
{
  int i;

  GPIO_SetBits(GPIOB, NEXYS4_OLED_DC); //data
  
  for (i = 0; i < 8; i++)
  {
    SPI_SendByte(OLEDChars[c * 8 + i]);
  }
}

void OLED_SendString(int line, char* s)
{
  int i = 0;

  GPIO_ResetBits(GPIOB, NEXYS4_OLED_DC); //command

  SPI_SendByte(0xB0 + line);
  SPI_SendByte(0x10);
  SPI_SendByte(0x00);

  while (i < 16) // clear line
  {
    OLED_SendChar(' ');
    i++;
  }

  i = 0;

  while (s[i] && (i < 16))
  {
    OLED_SendChar(s[i]);
    i++;
  }
}

/*int read_encoder()
{
  static int enc_states[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
  static int old_AB = 0;
  
  old_AB <<= 2;                   //remember previous state
  A = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
  B = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);
  old_AB |= A << 1;  //add current state
  old_AB |= B;  //add current state
  return ( enc_states[( old_AB & 0x0F )]);
}*/
